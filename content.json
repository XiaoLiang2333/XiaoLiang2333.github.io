{"meta":{"title":"Dawnbeam‘s Cyberhome","subtitle":"这里是晓梁，我家有些...什么好康的都还没有","description":"在写了在写了","author":"Dawnbeam","url":"https://xiaoliang2333.github.io","root":"/"},"pages":[],"posts":[{"title":"CSAPP阅读笔记","slug":"CSAPP Notebook","date":"2023-05-29T01:28:55.551Z","updated":"2023-05-29T01:30:30.007Z","comments":true,"path":"/post/CSAPP Notebook.html","link":"","permalink":"https://xiaoliang2333.github.io/post/CSAPP%20Notebook.html","excerpt":"","text":"CSAPP Notebook计算机系统漫游解密hello.c文件hello.c源文件hello程序是从hello.c源文件开始的,源程序实际上为值0和1字组成的位序列,8个位一组称为字节.每个字节表示程序中的某些文本字符,如在ASCII标准下,35这个单字节大小的整数值表示#这个预处理符号.只由ASCII字符构成的文件称为文本文件,其他所有文件都称为二进制文件.hello.c的表示方法说明了一个基本思想:系统中所有信息,如:磁盘文件,内存中的程序,存放的而用户数据以及网络上传送的数据,都是由一串比特构成的.区分这些数据对象的唯一方法就是我们读到这些数据对象时的上下文,这也就是我们程序员需要干的事. 细说hello程序的运行hello程序作为一个高级C语言程序,人类能很轻松的读懂,然而将他交给计算机系统,每条C语句必须被其他程序转化为低级机器语言指令.这些指令会被打包成可执行目标程序,并以二进制磁盘文件的形式存放起来.以Unix系统为例,GCC编译器驱动程序将hello程序从源文件转化到可执行目标程序分一下四个阶段: 预处理阶段: 预处理器(cpp)根据预处理符号#,修改原始的C程序,如#include&lt;stdio.h&gt;命令会告诉预处理器读取stdio.h的内容并直接复制粘贴到程序文本中,结果就得到了另一个C程序,通常以.i为文件扩展名,如hello.i 编译阶段: 编译器(cll)将hello.i翻译成由汇编语言构成的hello.s,汇编语言是一种低级机器语言指令,为不同高级语言的不同编译器提供了通用的输出语言. 汇编阶段: 汇编器(as)将hello.s翻译成机器语言指令,这才是计算机能直接看懂的语言,并将这些指令打包成一种叫可重定位目标程序的格式,并将结果保存为hello.o 链接阶段: 在hello程序中我们调用了以恶printf函数,它是每个C编译器都提供的C标准库中的函数,存在于一个名为printf.o的单独的预编译好了的目标文件中,这个文件必须以某种方式与我们的hello.o程序合并.链接器(ld)就负责处理这种合并.最后结果得到hello可执行(目标)文件,可以被加载到内存中由系统执行. 系统的硬件组成为了理解运行hello程序时发生了什么，我们需要对计算机硬件模型有个简单认知： 总线：贯穿整个系统的一组电子管道，负责在各个部件间传递信息字节。总线通常被设计成传送定长的字节块（word），字节块中的字节数（字长）是一个基本的系统参数，并且各个系统中不尽相同，要么是4个字节（32位）。要么是8个字节（64位） I&#x2F;O设备： 输入&#x2F;输出设备连接系统与外部世界（键盘鼠标、显示器、磁盘、网络适配器等），每个I&#x2F;O设备通过一个控制器（I&#x2F;O设备本身或主板上的芯片组）或适配器（一块插在主板插槽上的卡）与I&#x2F;O总线相连，他们的功能都是在I&#x2F;O总线和I&#x2F;O设备之间传递信息。 主存：即常说的内存。一个临时存储设备，可以在处理器执行程序时存放程序和程序处理的数据。主存是由动态随机存取存储器(DRAM）芯片组成的，抽象来看，存储器是一个线性的字节数组，每个字节都有其唯一地址（数组index），这些地址都是从零开始的。 处理器：即CPU，核心是一个大小位一个字的储存设备（或寄存器），称为程序计数器（PC）。任何时候，PC都只想主存的某条机器语言指令（即存着指令地址）。CPU一直在干一件事：执行PC指向的指令，更新PC，使其指向下一条指令。（当然实际上操作要复杂的多）。寄存器文件是CPU里一个小的存储设备，由一些单个字长的寄存器组成。算术/逻辑单元（ALU）如其名，负责计算信的数据和地址值。处理器执行一个指令的工作流程简单描述是这样的： 加载：从主存复制数据到寄存器，更新寄存器内容 存储：从寄存器复制数据到主存某个位置，更新主存这个位置的内容 操作： 把两个寄存器的内容复制到ALU进行算数运算，将结果更新到一个寄存器中。 跳转：从指令本身抽取数据（一个字）并更新到PC中。 解剖hello程序的运行简单描述系统硬件组成后，现在开始简单介绍运行hello程序时到底发生了什么。 当我们使用shell程序输入命令./hello后，shell程序会逐一读入这些字符到寄存器，然后存到内存中。 敲完回车后，shell程序便会执行一系列指令加载hello可执行文件，然后hello目标文件中的代码和数据（包括最终输出的字符串”hello,world\\n”）将从磁盘复制到主存，主存加载完这些数据后，CPU开始执行hello程序中main程序的机器语言指令，这些指令将”hello,world\\n”字符串的字节从主存复制到寄存器文件，再复制到显示设备，最终被我们看见。 操作系统管理硬件在hello程序运行的过程中，其实shell加载和运行hello程序以及hello程序输出时，这两个程序并没有直接访问键盘、显示器、磁盘这类硬件设备，而是依靠操作系统提供的服务访问的。操作系统可以看作应用程序（如这里的shell程序和hello程序）和硬件之间插入的一层软件，所有的应用程序对硬件的操作尝试都必须通过操作系统，这能有效防止硬件被失控的应用程序滥用，并可以向应用程序提供简单一致的机制来控制低级硬件设备。 进程hello程序在现代操作系统上运行时，看起来像是操作系统只有这个程序在运行，独占了CPU、主存、I&#x2F;O设备，CPU不间断地在一条接着一条地执行这个程序的指令。实际上这是一个假象，是通过进程这个概念实现的。进程是操作系统对一个正在运行的程序的一种抽象，一个系统上可以同时运行多个进程，而每个进程好像都独占了硬件。实际上这是通过并发运行，像小丑同时把玩三个球一样，通过处理器的调度，让不同进程间的指令交错执行。那么在这个过程中，操作系统需要保持跟踪进程运行所需的所有状态信息，也就是上下文（包括PC和寄存器文件的当前值、主存的内容等）。当操作系统决定要把控制权从当前进程转移到某个新进程时，就会进行上下文切换，即保存当前的上下文、恢复新进程的上下文，将控制权交给新进程，信进程就会从它上次停止的地方开始。比如在刚才使用shell程序执行hello程序的例子中，可以看到两个并发的进程：shell进程与hello进程。最开始只有shell进程在运行，在等待命令行的输入。当我们输入指令./hello后，shell会调用一个专门的函数:系统调用，将控制权传递给操作系统。此时操作系统会保存shell进程的上下文，创建一个新的hello进程及其上下文，然后传递控制权给hello进程。hello进程终止后（即输出完毕），再进行系统调用，操作系统会恢复shell进程的上下文，将控制权交还给shell进程，随后shell进程会等待下一个命令行输入。以上可以得知，从一个进程到另一个进程的转换是通过系统调用函数，交给操作系统内核（kernel）管理的。内核是操作系统代码常驻内存的部分，当应用程序需要操作系统执行某些操作时，它就会执行系统调用（system call）指令，将控制权交给内核，然后内核再执行被请求的操作后再返回应用程序。值得注意的是，内核并不是一个独立的进程，它只是系统管理全部进程所用代码和数据结构的集合。","categories":[],"tags":[]},{"title":"如何使用Hexo框架搭载并部署一个属于自己的静态博客网站","slug":"Build your personal Blog website","date":"2023-05-22T16:59:45.097Z","updated":"2023-05-24T15:32:09.053Z","comments":true,"path":"/post/Build your personal Blog website.html","link":"","permalink":"https://xiaoliang2333.github.io/post/Build%20your%20personal%20Blog%20website.html","excerpt":"","text":"提前准备： 一个github账号 安装并对git 有一点小了解 安装Node.js 学会使用bing自己解决问题 Quick Start安装Hexo使用Powershell&#x2F;git bash&#x2F;cmd ···输入： 1npm install -g hexo-cli 初始化Hexo安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。 123hexo init &lt;folder&gt; cd &lt;folder&gt;npm install &lt;folder&gt;替换为你想要存储博客文件的文件夹名。 新建完成后，指定文件夹的目录如下： 12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes 其中_config.yml文件是我们建站、部署博客需要经常用到的，其他文件的请详情参考Hexo官方文档 配置博客_config.yml文件中，有关于网站的配置条目如下： 1234567title: 你个人博客的标题subtitle: 你个人博客的子标题description: 你个人博客的简述keywords: 你个人博客的关键词author: 你的名字language: 语言timezone: 时区 简单配置完之后，我们就可以开始将博客部署到github上了。 部署博客 新建一个用于储存你博客网站源代码的仓库，仓库名必须为你的github名.github.io(建议设置为公开) 使用git bash输入命令cd &lt;folder&gt;进入到博客文件夹,输入命令npm install hexo-deployer-git --save安装 hexo-deployer-git 修改博客配置文件_config.yml,最下文deploy行：12345deploy: type: git repo: [repository url]刚刚新建的仓库地址 branch: [branch](通常为main) message: [message] (若没有repo、branch等行请自行添加) 执行 hexo clean &amp;&amp; hexo deploy，生成站点文件并推送至远程库。(如果遇到网络问题导致推送失败，请设置git代理，以clash为例，git bash中输入命令： git config --global https.proxy https://127.0.0.1:7890 &#x2F;&#x2F;7890为clash默认端口) 设置github pages：进入刚新建的仓库，-settings -Pages,将默认分支设置为_config.yml配置中的分支名称（通常是main）。稍等片刻，即可以通过你的github名.github.io&#96;访问你的个人博客了！ 以上，你便成功的在github上部署好了自己的个人博客网站，快去写你自己的第一篇博客吧！","categories":[],"tags":[]}],"categories":[],"tags":[]}